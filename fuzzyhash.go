package fuzzyhash

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"math"
	"slices"
	"strconv"
	"strings"
)

// FuzzyHash represents a hash generated fuzzily.
type FuzzyHash struct {
	// C is populated as the output of the fuzzy
	// hash function.
	C []byte
	// T is the number of bytes generated from the
	// input bytes. The higher this number is the less
	// fuzzy the hash is.
	T int
}

// roughMedian calculates the rough median of an array of numbers.
func roughMedian[T int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64](s []T) T {
	var numbers []float64
	for _, num := range s {
		numbers = append(numbers, float64(num))
	}
	slices.Sort(numbers)
	return T(numbers[int(math.Floor(float64(len(numbers))/2.0))])
}

// Hash takes in input bytes (k) and integer (s) to measure the fuzzyness.
// The larger s is, the more fuzzy the hash will be.
func Hash(k []byte, s int) *FuzzyHash {
	kh := []uint8(hex.EncodeToString(k))
	t := len(kh) / s
	kha := roughMedian(kh)
	padding := slices.Repeat([]uint8{kha}, len(kh)%t)
	key := append(kh, padding...)
	fuzzyHash := &FuzzyHash{T: t}
	var uc []uint8
	for i := range len(key) / t {
		buffer := key[i*t : i*t+t]
		s := roughMedian(buffer)
		uc = append(uc, s)
	}
	hasher := sha256.New()
	hasher.Write(uc)
	fuzzyHash.C = hasher.Sum(nil)
	return fuzzyHash
}

// String returns the output bytes in hexadecimal form.
func (f FuzzyHash) String() string {
	return hex.EncodeToString(f.C)
}

// MarshalString marshals the FuzzyHash into a string.
func (f FuzzyHash) MarshalString() string {
	c := hex.EncodeToString(f.C)
	return fmt.Sprintf("%s:%d", c, f.T)
}

// UnmarshalString unmarshals a string (generated by MarshalString)
// into a FuzzyHash. It may return an error if the string is invalid.
func UnmarshalString(fh string) (*FuzzyHash, error) {
	nf := new(FuzzyHash)
	parts := strings.Split(fh, ":")
	if len(parts) != 2 {
		return nil, fmt.Errorf("string cannot be made into fuzzyhash: its formatting is invalid.")
	}
	ce := parts[0]
	ts := parts[1]

	c, err := hex.DecodeString(ce)
	if err != nil {
		return nil, fmt.Errorf("string cannot be made into fuzzyhash: specified c value is not hex encoded")
	}
	nf.C = c

	t, err := strconv.Atoi(ts)
	if err != nil {
		return nil, fmt.Errorf("string cannot be made into fuzzyhash: specified t value is not an integer")
	}
	nf.T = t
	return nf, nil
}

// Equal checks for the equality of the output bytes
// of two fuzzyhashes.
func Equal(f1 *FuzzyHash, f2 *FuzzyHash) bool {
	return f1.String() == f2.String()
}
